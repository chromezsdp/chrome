{"./":{"url":"./","title":"chrome知识店铺","keywords":"","body":"new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"geng-xin-ji-hua.html":{"url":"geng-xin-ji-hua.html","title":"更新计划","summary":"下次更新的内容和时间","keywords":"","body":"更新计划主要内容字符串：更新日期：2021-5-5更新计划 主要内容 字符串：更新日期：2021-5-5 字符串编码转换 字符串类型转换 跨平台字符处理 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"cha-jian-fen-xiang.html":{"url":"cha-jian-fen-xiang.html","title":"插件分享","summary":"分享好用的chrome插件","keywords":"","body":"插件分享插件分享 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"xin-shou-jiao-cheng.html":{"url":"xin-shou-jiao-cheng.html","title":"新手教程","keywords":"","body":"新手教程新手教程 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-dong-tai.html":{"url":"ji-shu-dong-tai.html","title":"技术动态","summary":"chrome技术资讯","keywords":"","body":"技术动态技术动态 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/":{"url":"ji-shu-fen-xi/","title":"技术分析","summary":"对chrome源代码的学习","keywords":"","body":"技术分析说明目录目的技术分析 说明 目录 目录根据chrome源码下的目录对应生成 目的 分享chrome优秀设计 分享chrome中的技术 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/wang-luo-zhan/":{"url":"ji-shu-fen-xi/wang-luo-zhan/","title":"网络栈","keywords":"","body":"网络栈网络栈 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/wang-luo-zhan/dns-jie-xi.html":{"url":"ji-shu-fen-xi/wang-luo-zhan/dns-jie-xi.html","title":"DNS解析","keywords":"","body":"DNS解析DNS解析 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/nei-he/":{"url":"ji-shu-fen-xi/nei-he/","title":"内核","keywords":"","body":"内核内核 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/nei-he/blink.html":{"url":"ji-shu-fen-xi/nei-he/blink.html","title":"Blink","keywords":"","body":"BlinkBlink new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/":{"url":"ji-shu-fen-xi/ji-chu-ku/","title":"基础库","keywords":"","body":"基础库基础库 new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/win.html":{"url":"ji-shu-fen-xi/ji-chu-ku/win.html","title":"win","keywords":"","body":"winwin new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/tong-yong-util.html":{"url":"ji-shu-fen-xi/ji-chu-ku/tong-yong-util.html","title":"通用（util）","keywords":"","body":"通用（util）通用（util） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/shi-jian-zhui-zong-traceevent.html":{"url":"ji-shu-fen-xi/ji-chu-ku/shi-jian-zhui-zong-traceevent.html","title":"事件追踪（trace_event）","keywords":"","body":"事件追踪（trace_event）事件追踪（trace_event） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/ding-shi-qi-timer.html":{"url":"ji-shu-fen-xi/ji-chu-ku/ding-shi-qi-timer.html","title":"定时器（timer）","keywords":"","body":"定时器（timer）定时器（timer） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/shi-jian-time.html":{"url":"ji-shu-fen-xi/ji-chu-ku/shi-jian-time.html","title":"时间（time）","keywords":"","body":"时间（time）时间（time） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/xian-cheng-threading.html":{"url":"ji-shu-fen-xi/ji-chu-ku/xian-cheng-threading.html","title":"线程（threading）","keywords":"","body":"线程（threading）线程（threading） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/di-san-fang-ku-thirdparty.html":{"url":"ji-shu-fen-xi/ji-chu-ku/di-san-fang-ku-thirdparty.html","title":"第三方库（third_party）","keywords":"","body":"第三方库（third_party）第三方库（third_party） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/ce-shi-test.html":{"url":"ji-shu-fen-xi/ji-chu-ku/ce-shi-test.html","title":"测试（test）","keywords":"","body":"测试（test）测试（test） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/ren-wu-task.html":{"url":"ji-shu-fen-xi/ji-chu-ku/ren-wu-task.html","title":"任务（task）","keywords":"","body":"任务（task）任务（task） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/xi-tong-system.html":{"url":"ji-shu-fen-xi/ji-chu-ku/xi-tong-system.html","title":"系统（system）","keywords":"","body":"系统（system）系统（system） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/tong-bu-synchronization.html":{"url":"ji-shu-fen-xi/ji-chu-ku/tong-bu-synchronization.html","title":"同步（synchronization）","keywords":"","body":"同步（synchronization）同步（synchronization） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/zi-fu-chuan-strings/":{"url":"ji-shu-fen-xi/ji-chu-ku/zi-fu-chuan-strings/","title":"字符串（strings）","keywords":"","body":"字符串（strings）字符串（strings） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/zi-fu-chuan-strings/zi-fu-chuan-lei-xing-zhuan-huan.html":{"url":"ji-shu-fen-xi/ji-chu-ku/zi-fu-chuan-strings/zi-fu-chuan-lei-xing-zhuan-huan.html","title":"字符串类型转换","summary":"chrome中字符串类型转换","keywords":"","body":"字符串类型转换相关文件方法定义数字转换字符串字符串转换数字十六进制编码windows方法实现internalfuzzerwindows字符串类型转换 字符串类型转换主要设计数字于字符转之间的转换和十六进制编码 相关文件 base/strings/string_number_conversions.h // std::string、std::u16string与数字之间的转换定义 base/strings/string_number_conversions.cc // std::string、std::u16string与数字之间的转换实现 base/strings/string_number_conversions_fuzzer.cc // 数字与字符转转换实现 base/strings/string_number_conversions_internal.h // 数字与字符转转换实现 base/strings/string_number_conversions_win.h // std::wstring与数字之间的转换定义 base/strings/string_number_conversions_win.cc // std::wstring与数字之间的转换实现 方法定义 数字转换字符串 使用函数重载的方式实现使开发不需要记忆大量的函数名，只需关心需要的字符串类型string或u16string。 字符串转换数字 字符串转换数字有可能失败，需要判断StringTo*返回是否为true。 十六进制编码 十六进制表示法在编程中非常常见，将十六进制编码字符转换为对应的数据类型，是对“字符串转换数字”的一个扩充。 // base/strings/string_number_conversions.h namespace base { // Number -> string conversions ------------------------------------------------ // Ignores locale! see warning above. BASE_EXPORT std::string NumberToString(int value); BASE_EXPORT std::u16string NumberToString16(int value); BASE_EXPORT std::string NumberToString(unsigned int value); BASE_EXPORT std::u16string NumberToString16(unsigned int value); BASE_EXPORT std::string NumberToString(long value); BASE_EXPORT std::u16string NumberToString16(long value); BASE_EXPORT std::string NumberToString(unsigned long value); BASE_EXPORT std::u16string NumberToString16(unsigned long value); BASE_EXPORT std::string NumberToString(long long value); BASE_EXPORT std::u16string NumberToString16(long long value); BASE_EXPORT std::string NumberToString(unsigned long long value); BASE_EXPORT std::u16string NumberToString16(unsigned long long value); BASE_EXPORT std::string NumberToString(double value); BASE_EXPORT std::u16string NumberToString16(double value); // String -> number conversions ------------------------------------------------ // Perform a best-effort conversion of the input string to a numeric type, // setting |*output| to the result of the conversion. Returns true for // \"perfect\" conversions; returns false in the following cases: // - Overflow. |*output| will be set to the maximum value supported // by the data type. // - Underflow. |*output| will be set to the minimum value supported // by the data type. // - Trailing characters in the string after parsing the number. |*output| // will be set to the value of the number that was parsed. // - Leading whitespace in the string before parsing the number. |*output| will // be set to the value of the number that was parsed. // - No characters parseable as a number at the beginning of the string. // |*output| will be set to 0. // - Empty string. |*output| will be set to 0. // WARNING: Will write to |output| even when returning false. // Read the comments above carefully. BASE_EXPORT bool StringToInt(StringPiece input, int* output); BASE_EXPORT bool StringToInt(StringPiece16 input, int* output); BASE_EXPORT bool StringToUint(StringPiece input, unsigned* output); BASE_EXPORT bool StringToUint(StringPiece16 input, unsigned* output); BASE_EXPORT bool StringToInt64(StringPiece input, int64_t* output); BASE_EXPORT bool StringToInt64(StringPiece16 input, int64_t* output); BASE_EXPORT bool StringToUint64(StringPiece input, uint64_t* output); BASE_EXPORT bool StringToUint64(StringPiece16 input, uint64_t* output); BASE_EXPORT bool StringToSizeT(StringPiece input, size_t* output); BASE_EXPORT bool StringToSizeT(StringPiece16 input, size_t* output); // For floating-point conversions, only conversions of input strings in decimal // form are defined to work. Behavior with strings representing floating-point // numbers in hexadecimal, and strings representing non-finite values (such as // NaN and inf) is undefined. Otherwise, these behave the same as the integral // variants. This expects the input string to NOT be specific to the locale. // If your input is locale specific, use ICU to read the number. // WARNING: Will write to |output| even when returning false. // Read the comments here and above StringToInt() carefully. BASE_EXPORT bool StringToDouble(StringPiece input, double* output); BASE_EXPORT bool StringToDouble(StringPiece16 input, double* output); // Hex encoding ---------------------------------------------------------------- // Returns a hex string representation of a binary buffer. The returned hex // string will be in upper case. This function does not check if |size| is // within reasonable limits since it's written with trusted data in mind. If // you suspect that the data you want to format might be large, the absolute // max size for |size| should be is // std::numeric_limits::max() / 2 BASE_EXPORT std::string HexEncode(const void* bytes, size_t size); BASE_EXPORT std::string HexEncode(base::span bytes); // Best effort conversion, see StringToInt above for restrictions. // Will only successful parse hex values that will fit into |output|, i.e. // -0x80000000 * output); // Same as HexStringToBytes, but for an std::string. BASE_EXPORT bool HexStringToString(StringPiece input, std::string* output); // Decodes the hex string |input| into a presized |output|. The output buffer // must be sized exactly to |input.size() / 2| or decoding will fail and no // bytes will be written to |output|. Decoding an empty input is also // considered a failure. When decoding fails due to encountering invalid input // characters, |output| will have been filled with the decoded bytes up until // the failure. BASE_EXPORT bool HexStringToSpan(StringPiece input, base::span output); } // namespace base windows // base/strings/string_number_conversions_win.h namespace base { BASE_EXPORT std::wstring NumberToWString(int value); BASE_EXPORT std::wstring NumberToWString(unsigned int value); BASE_EXPORT std::wstring NumberToWString(long value); BASE_EXPORT std::wstring NumberToWString(unsigned long value); BASE_EXPORT std::wstring NumberToWString(long long value); BASE_EXPORT std::wstring NumberToWString(unsigned long long value); BASE_EXPORT std::wstring NumberToWString(double value); // The following section contains overloads of the cross-platform APIs for // std::wstring and base::WStringPiece. BASE_EXPORT bool StringToInt(WStringPiece input, int* output); BASE_EXPORT bool StringToUint(WStringPiece input, unsigned* output); BASE_EXPORT bool StringToInt64(WStringPiece input, int64_t* output); BASE_EXPORT bool StringToUint64(WStringPiece input, uint64_t* output); BASE_EXPORT bool StringToSizeT(WStringPiece input, size_t* output); BASE_EXPORT bool StringToDouble(WStringPiece input, double* output); } // namespace base 方法实现 // base/strings/string_number_conversions.cc namespace base { std::string NumberToString(int value) { return internal::IntToStringT(value); } std::u16string NumberToString16(int value) { return internal::IntToStringT(value); } std::string NumberToString(unsigned value) { return internal::IntToStringT(value); } std::u16string NumberToString16(unsigned value) { return internal::IntToStringT(value); } std::string NumberToString(long value) { return internal::IntToStringT(value); } std::u16string NumberToString16(long value) { return internal::IntToStringT(value); } std::string NumberToString(unsigned long value) { return internal::IntToStringT(value); } std::u16string NumberToString16(unsigned long value) { return internal::IntToStringT(value); } std::string NumberToString(long long value) { return internal::IntToStringT(value); } std::u16string NumberToString16(long long value) { return internal::IntToStringT(value); } std::string NumberToString(unsigned long long value) { return internal::IntToStringT(value); } std::u16string NumberToString16(unsigned long long value) { return internal::IntToStringT(value); } std::string NumberToString(double value) { return internal::DoubleToStringT(value); } std::u16string NumberToString16(double value) { return internal::DoubleToStringT(value); } bool StringToInt(StringPiece input, int* output) { return internal::StringToIntImpl(input, *output); } bool StringToInt(StringPiece16 input, int* output) { return internal::StringToIntImpl(input, *output); } bool StringToUint(StringPiece input, unsigned* output) { return internal::StringToIntImpl(input, *output); } bool StringToUint(StringPiece16 input, unsigned* output) { return internal::StringToIntImpl(input, *output); } bool StringToInt64(StringPiece input, int64_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToInt64(StringPiece16 input, int64_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToUint64(StringPiece input, uint64_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToUint64(StringPiece16 input, uint64_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToSizeT(StringPiece input, size_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToSizeT(StringPiece16 input, size_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToDouble(StringPiece input, double* output) { return internal::StringToDoubleImpl(input, input.data(), *output); } bool StringToDouble(StringPiece16 input, double* output) { return internal::StringToDoubleImpl( input, reinterpret_cast(input.data()), *output); } std::string HexEncode(const void* bytes, size_t size) { static const char kHexChars[] = \"0123456789ABCDEF\"; // Each input byte creates two output hex characters. std::string ret(size * 2, '\\0'); for (size_t i = 0; i (bytes)[i]; ret[(i * 2)] = kHexChars[(b >> 4) & 0xf]; ret[(i * 2) + 1] = kHexChars[b & 0xf]; } return ret; } std::string HexEncode(base::span bytes) { return HexEncode(bytes.data(), bytes.size()); } bool HexStringToInt(StringPiece input, int* output) { return internal::HexStringToIntImpl(input, *output); } bool HexStringToUInt(StringPiece input, uint32_t* output) { return internal::HexStringToIntImpl(input, *output); } bool HexStringToInt64(StringPiece input, int64_t* output) { return internal::HexStringToIntImpl(input, *output); } bool HexStringToUInt64(StringPiece input, uint64_t* output) { return internal::HexStringToIntImpl(input, *output); } bool HexStringToBytes(StringPiece input, std::vector* output) { DCHECK(output->empty()); return internal::HexStringToByteContainer(input, std::back_inserter(*output)); } bool HexStringToString(StringPiece input, std::string* output) { DCHECK(output->empty()); return internal::HexStringToByteContainer(input, std::back_inserter(*output)); } bool HexStringToSpan(StringPiece input, base::span output) { if (input.size() / 2 != output.size()) return false; return internal::HexStringToByteContainer(input, output.begin()); } } // namespace base internal // base/strings/string_number_conversions_internal.h namespace base { namespace internal { template static STR IntToStringT(INT value) { // log10(2) ~= 0.3 bytes needed per bit or per byte log10(2**8) ~= 2.4. // So round up to allocate 3 output characters per byte, plus 1 for '-'. const size_t kOutputBufSize = 3 * sizeof(INT) + std::numeric_limits::is_signed; // Create the string in a temporary buffer, write it back to front, and // then return the substr of what we ended up using. using CHR = typename STR::value_type; CHR outbuf[kOutputBufSize]; // The ValueOrDie call below can never fail, because UnsignedAbs is valid // for all valid inputs. std::make_unsigned_t res = CheckedNumeric(value).UnsignedAbs().ValueOrDie(); CHR* end = outbuf + kOutputBufSize; CHR* i = end; do { --i; DCHECK(i != outbuf); *i = static_cast((res % 10) + '0'); res /= 10; } while (res != 0); if (IsValueNegative(value)) { --i; DCHECK(i != outbuf); *i = static_cast('-'); } return STR(i, end); } // Utility to convert a character to a digit in a given base template Optional CharToDigit(CHAR c) { static_assert(1 = '0' && c = 'a' && c = 'A' && c class WhitespaceHelper {}; template <> class WhitespaceHelper { public: static bool Invoke(char c) { return 0 != isspace(static_cast(c)); } }; template <> class WhitespaceHelper { public: static bool Invoke(char16_t c) { return 0 != iswspace(c); } }; template bool LocalIsWhitespace(CHAR c) { return WhitespaceHelper::Invoke(c); } template class StringToNumberParser { public: struct Result { Number value = 0; bool valid = false; }; static constexpr Number kMin = std::numeric_limits::min(); static constexpr Number kMax = std::numeric_limits::max(); // Sign provides: // - a static function, CheckBounds, that determines whether the next digit // causes an overflow/underflow // - a static function, Increment, that appends the next digit appropriately // according to the sign of the number being parsed. template class Base { public: template static Result Invoke(Iter begin, Iter end) { Number value = 0; if (begin == end) { return {value, false}; } // Note: no performance difference was found when using template // specialization to remove this check in bases other than 16 if (kBase == 16 && end - begin > 2 && *begin == '0' && (*(begin + 1) == 'x' || *(begin + 1) == 'X')) { begin += 2; } for (Iter current = begin; current != end; ++current) { Optional new_digit = CharToDigit(*current); if (!new_digit) { return {value, false}; } if (current != begin) { Result result = Sign::CheckBounds(value, *new_digit); if (!result.valid) return result; value *= kBase; } value = Sign::Increment(value, *new_digit); } return {value, true}; } }; class Positive : public Base { public: static Result CheckBounds(Number value, uint8_t new_digit) { if (value > static_cast(kMax / kBase) || (value == static_cast(kMax / kBase) && new_digit > kMax % kBase)) { return {kMax, false}; } return {value, true}; } static Number Increment(Number lhs, uint8_t rhs) { return lhs + rhs; } }; class Negative : public Base { public: static Result CheckBounds(Number value, uint8_t new_digit) { if (value 0 - kMin % kBase)) { return {kMin, false}; } return {value, true}; } static Number Increment(Number lhs, uint8_t rhs) { return lhs - rhs; } }; }; template auto StringToNumber(BasicStringPiece input) { using Parser = StringToNumberParser; using Result = typename Parser::Result; bool has_leading_whitespace = false; auto begin = input.begin(); auto end = input.end(); while (begin != end && LocalIsWhitespace(*begin)) { has_leading_whitespace = true; ++begin; } if (begin != end && *begin == '-') { if (!std::numeric_limits::is_signed) { return Result{0, false}; } Result result = Parser::Negative::Invoke(begin + 1, end); result.valid &= !has_leading_whitespace; return result; } if (begin != end && *begin == '+') { ++begin; } Result result = Parser::Positive::Invoke(begin, end); result.valid &= !has_leading_whitespace; return result; } template bool StringToIntImpl(BasicStringPiece input, VALUE& output) { auto result = StringToNumber(input); output = result.value; return result.valid; } template bool HexStringToIntImpl(BasicStringPiece input, VALUE& output) { auto result = StringToNumber(input); output = result.value; return result.valid; } static const double_conversion::DoubleToStringConverter* GetDoubleToStringConverter() { static NoDestructor converter( double_conversion::DoubleToStringConverter::EMIT_POSITIVE_EXPONENT_SIGN, nullptr, nullptr, 'e', -6, 12, 0, 0); return converter.get(); } // Converts a given (data, size) pair to a desired string type. For // performance reasons, this dispatches to a different constructor if the // passed-in data matches the string's value_type. template StringT ToString(const typename StringT::value_type* data, size_t size) { return StringT(data, size); } template StringT ToString(const CharT* data, size_t size) { return StringT(data, data + size); } template StringT DoubleToStringT(double value) { char buffer[32]; double_conversion::StringBuilder builder(buffer, sizeof(buffer)); GetDoubleToStringConverter()->ToShortest(value, &builder); return ToString(buffer, builder.position()); } template bool StringToDoubleImpl(STRING input, const CHAR* data, double& output) { static NoDestructor converter( double_conversion::StringToDoubleConverter::ALLOW_LEADING_SPACES | double_conversion::StringToDoubleConverter::ALLOW_TRAILING_JUNK, 0.0, 0, nullptr, nullptr); int processed_characters_count; output = converter->StringToDouble(data, input.size(), &processed_characters_count); // Cases to return false: // - If the input string is empty, there was nothing to parse. // - If the value saturated to HUGE_VAL. // - If the entire string was not processed, there are either characters // remaining in the string after a parsed number, or the string does not // begin with a parseable number. // - If the first character is a space, there was leading whitespace return !input.empty() && output != HUGE_VAL && output != -HUGE_VAL && static_cast(processed_characters_count) == input.size() && !IsUnicodeWhitespace(input[0]); } template static bool HexStringToByteContainer(StringPiece input, OutIter output) { size_t count = input.size(); if (count == 0 || (count % 2) != 0) return false; for (uintptr_t i = 0; i msb = CharToDigit(input[i * 2]); // least significant 4 bits Optional lsb = CharToDigit(input[i * 2 + 1]); if (!msb || !lsb) { return false; } *(output++) = (*msb fuzzer // base/strings/string_number_conversions_fuzzer.cc template void CheckRoundtripsT(const uint8_t* data, const size_t size, StringType (*num_to_string)(NumberType), bool (*string_to_num)(StringPieceType, NumberType*)) { // Ensure we can read a NumberType from |data| if (size (data); // Because we started with an arbitrary NumberType value, not an arbitrary // string, we expect that the function |string_to_num| (e.g. StringToInt) will // return true, indicating a perfect conversion. NumberType v2; CHECK(string_to_num(num_to_string(v1), &v2)); // Given that this was a perfect conversion, we expect the original NumberType // value to equal the newly parsed one. CHECK_EQ(v1, v2); } template void CheckRoundtrips(const uint8_t* data, const size_t size, bool (*string_to_num)(base::StringPiece, NumberType*)) { return CheckRoundtripsT( data, size, &base::NumberToString, string_to_num); } template void CheckRoundtrips16(const uint8_t* data, const size_t size, bool (*string_to_num)(base::StringPiece16, NumberType*)) { return CheckRoundtripsT( data, size, &base::NumberToString16, string_to_num); } // Entry point for LibFuzzer. extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { // For each instantiation of NumberToString f and its corresponding StringTo* // function g, check that f(g(x)) = x holds for fuzzer-determined values of x. CheckRoundtrips(data, size, &base::StringToInt); CheckRoundtrips16(data, size, &base::StringToInt); CheckRoundtrips(data, size, &base::StringToUint); CheckRoundtrips16(data, size, &base::StringToUint); CheckRoundtrips(data, size, &base::StringToInt64); CheckRoundtrips16(data, size, &base::StringToInt64); CheckRoundtrips(data, size, &base::StringToUint64); CheckRoundtrips16(data, size, &base::StringToUint64); CheckRoundtrips(data, size, &base::StringToSizeT); CheckRoundtrips16(data, size, &base::StringToSizeT); base::StringPiece string_piece_input(reinterpret_cast(data), size); std::string string_input(reinterpret_cast(data), size); int out_int; base::StringToInt(string_piece_input, &out_int); unsigned out_uint; base::StringToUint(string_piece_input, &out_uint); int64_t out_int64; base::StringToInt64(string_piece_input, &out_int64); uint64_t out_uint64; base::StringToUint64(string_piece_input, &out_uint64); size_t out_size; base::StringToSizeT(string_piece_input, &out_size); // Test for StringPiece16 if size is even. if (size % 2 == 0) { base::StringPiece16 string_piece_input16( reinterpret_cast(data), size / 2); base::StringToInt(string_piece_input16, &out_int); base::StringToUint(string_piece_input16, &out_uint); base::StringToInt64(string_piece_input16, &out_int64); base::StringToUint64(string_piece_input16, &out_uint64); base::StringToSizeT(string_piece_input16, &out_size); } double out_double; base::StringToDouble(string_input, &out_double); base::HexStringToInt(string_piece_input, &out_int); base::HexStringToUInt(string_piece_input, &out_uint); base::HexStringToInt64(string_piece_input, &out_int64); base::HexStringToUInt64(string_piece_input, &out_uint64); std::vector out_bytes; base::HexStringToBytes(string_piece_input, &out_bytes); base::HexEncode(data, size); // Convert the numbers back to strings. base::NumberToString(out_int); base::NumberToString16(out_int); base::NumberToString(out_uint); base::NumberToString16(out_uint); base::NumberToString(out_int64); base::NumberToString16(out_int64); base::NumberToString(out_uint64); base::NumberToString16(out_uint64); base::NumberToString(out_double); base::NumberToString16(out_double); return 0; } windows // base/strings/string_number_conversions_win.cc namespace base { std::wstring NumberToWString(int value) { return internal::IntToStringT(value); } std::wstring NumberToWString(unsigned value) { return internal::IntToStringT(value); } std::wstring NumberToWString(long value) { return internal::IntToStringT(value); } std::wstring NumberToWString(unsigned long value) { return internal::IntToStringT(value); } std::wstring NumberToWString(long long value) { return internal::IntToStringT(value); } std::wstring NumberToWString(unsigned long long value) { return internal::IntToStringT(value); } std::wstring NumberToWString(double value) { return internal::DoubleToStringT(value); } namespace internal { template <> class WhitespaceHelper { public: static bool Invoke(wchar_t c) { return 0 != iswspace(c); } }; } // namespace internal bool StringToInt(WStringPiece input, int* output) { return internal::StringToIntImpl(input, *output); } bool StringToUint(WStringPiece input, unsigned* output) { return internal::StringToIntImpl(input, *output); } bool StringToInt64(WStringPiece input, int64_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToUint64(WStringPiece input, uint64_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToSizeT(WStringPiece input, size_t* output) { return internal::StringToIntImpl(input, *output); } bool StringToDouble(WStringPiece input, double* output) { return internal::StringToDoubleImpl( input, reinterpret_cast(input.data()), *output); } } // namespace base new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/zi-fu-chuan-strings/zi-fu-chuan-bian-ma-zhuan-huan.html":{"url":"ji-shu-fen-xi/ji-chu-ku/zi-fu-chuan-strings/zi-fu-chuan-bian-ma-zhuan-huan.html","title":"字符串编码转换","summary":"chrome中字符串编码转换实现方式","keywords":"","body":"字符串编码转换相关文件方法定义方法实现fuzzer字符串编码转换 字符串编码转换涉及宽字节表示法与UTF-8表示法之间的转换、宽字节表示法与UTF-16表示法之间的转换、UTF-8表示法与UTF-16表示法之间的转换、UTF-16表示法于ASCII表示法之间的转换、ASCII表示法宽字节表示法之间的转换。 相关文件 base/strings/utf_string_conversions.h // 字符串编码转换定义 base/strings/utf_string_conversions.cc // 字符串编码转换实现 base/strings/utf_string_conversions_fuzzer.cc // 字符串编码转换实现 方法定义 // base/strings/utf_string_conversions.h namespace base { // These convert between UTF-8, -16, and -32 strings. They are potentially slow, // so avoid unnecessary conversions. The low-level versions return a boolean // indicating whether the conversion was 100% valid. In this case, it will still // do the best it can and put the result in the output buffer. The versions that // return strings ignore this error and just return the best conversion // possible. BASE_EXPORT bool WideToUTF8(const wchar_t* src, size_t src_len, std::string* output); BASE_EXPORT std::string WideToUTF8(WStringPiece wide) WARN_UNUSED_RESULT; BASE_EXPORT bool UTF8ToWide(const char* src, size_t src_len, std::wstring* output); BASE_EXPORT std::wstring UTF8ToWide(StringPiece utf8) WARN_UNUSED_RESULT; BASE_EXPORT bool WideToUTF16(const wchar_t* src, size_t src_len, std::u16string* output); BASE_EXPORT std::u16string WideToUTF16(WStringPiece wide) WARN_UNUSED_RESULT; BASE_EXPORT bool UTF16ToWide(const char16_t* src, size_t src_len, std::wstring* output); BASE_EXPORT std::wstring UTF16ToWide(StringPiece16 utf16) WARN_UNUSED_RESULT; BASE_EXPORT bool UTF8ToUTF16(const char* src, size_t src_len, std::u16string* output); BASE_EXPORT std::u16string UTF8ToUTF16(StringPiece utf8) WARN_UNUSED_RESULT; BASE_EXPORT bool UTF16ToUTF8(const char16_t* src, size_t src_len, std::string* output); BASE_EXPORT std::string UTF16ToUTF8(StringPiece16 utf16) WARN_UNUSED_RESULT; // This converts an ASCII string, typically a hardcoded constant, to a UTF16 // string. BASE_EXPORT std::u16string ASCIIToUTF16(StringPiece ascii) WARN_UNUSED_RESULT; // Converts to 7-bit ASCII by truncating. The result must be known to be ASCII // beforehand. BASE_EXPORT std::string UTF16ToASCII(StringPiece16 utf16) WARN_UNUSED_RESULT; #if defined(WCHAR_T_IS_UTF16) // This converts an ASCII string, typically a hardcoded constant, to a wide // string. BASE_EXPORT std::wstring ASCIIToWide(StringPiece ascii) WARN_UNUSED_RESULT; // Converts to 7-bit ASCII by truncating. The result must be known to be ASCII // beforehand. BASE_EXPORT std::string WideToASCII(WStringPiece wide) WARN_UNUSED_RESULT; #endif // defined(WCHAR_T_IS_UTF16) // The conversion functions in this file should not be used to convert string // literals. Instead, the corresponding prefixes (e.g. u\"\" for UTF16 or L\"\" for // Wide) should be used. Deleting the overloads here catches these cases at // compile time. template std::u16string WideToUTF16(const wchar_t (&str)[N]) { static_assert(N == 0, \"Error: Use the u\\\"...\\\" prefix instead.\"); return std::u16string(); } // TODO(crbug.com/1189439): Also disallow passing string constants in tests. #if !defined(UNIT_TEST) template std::u16string ASCIIToUTF16(const char (&str)[N]) { static_assert(N == 0, \"Error: Use the u\\\"...\\\" prefix instead.\"); return std::u16string(); } // Mutable character arrays are usually only populated during runtime. Continue // to allow this conversion. template std::u16string ASCIIToUTF16(char (&str)[N]) { return ASCIIToUTF16(StringPiece(str)); } #endif } // namespace base 方法实现 // base/strings/utf_string_conversions.cc namespace base { namespace { constexpr int32_t kErrorCodePoint = 0xFFFD; // Size coefficient ---------------------------------------------------------- // The maximum number of codeunits in the destination encoding corresponding to // one codeunit in the source encoding. template struct SizeCoefficient { static_assert(sizeof(SrcChar) struct SizeCoefficient { // One UTF-16 codeunit corresponds to at most 3 codeunits in UTF-8. static constexpr int value = 3; }; #if defined(WCHAR_T_IS_UTF32) template <> struct SizeCoefficient { // UTF-8 uses at most 4 codeunits per character. static constexpr int value = 4; }; template <> struct SizeCoefficient { // UTF-16 uses at most 2 codeunits per character. static constexpr int value = 2; }; #endif // defined(WCHAR_T_IS_UTF32) template constexpr int size_coefficient_v = SizeCoefficient, std::decay_t>::value; // UnicodeAppendUnsafe -------------------------------------------------------- // Function overloads that write code_point to the output string. Output string // has to have enough space for the codepoint. // Convenience typedef that checks whether the passed in type is integral (i.e. // bool, char, int or their extended versions) and is of the correct size. template using EnableIfBitsAre = std::enable_if_t::value && CHAR_BIT * sizeof(Char) == N, bool>; template = true> void UnicodeAppendUnsafe(Char* out, int32_t* size, uint32_t code_point) { CBU8_APPEND_UNSAFE(out, *size, code_point); } template = true> void UnicodeAppendUnsafe(Char* out, int32_t* size, uint32_t code_point) { CBU16_APPEND_UNSAFE(out, *size, code_point); } template = true> void UnicodeAppendUnsafe(Char* out, int32_t* size, uint32_t code_point) { out[(*size)++] = code_point; } // DoUTFConversion ------------------------------------------------------------ // Main driver of UTFConversion specialized for different Src encodings. // dest has to have enough room for the converted text. template bool DoUTFConversion(const char* src, int32_t src_len, DestChar* dest, int32_t* dest_len) { bool success = true; for (int32_t i = 0; i bool DoUTFConversion(const char16_t* src, int32_t src_len, DestChar* dest, int32_t* dest_len) { bool success = true; auto ConvertSingleChar = [&success](char16_t in) -> int32_t { if (!CBU16_IS_SINGLE(in) || !IsValidCodepoint(in)) { success = false; return kErrorCodePoint; } return in; }; int32_t i = 0; // Always have another symbol in order to avoid checking boundaries in the // middle of the surrogate pair. while (i bool DoUTFConversion(const wchar_t* src, int32_t src_len, DestChar* dest, int32_t* dest_len) { bool success = true; for (int32_t i = 0; i bool UTFConversion(const InputString& src_str, DestString* dest_str) { if (IsStringASCII(src_str)) { dest_str->assign(src_str.begin(), src_str.end()); return true; } dest_str->resize(src_str.length() * size_coefficient_v); // Empty string is ASCII => it OK to call operator[]. auto* dest = &(*dest_str)[0]; // ICU requires 32 bit numbers. int32_t src_len32 = static_cast(src_str.length()); int32_t dest_len32 = 0; bool res = DoUTFConversion(src_str.data(), src_len32, dest, &dest_len32); dest_str->resize(dest_len32); dest_str->shrink_to_fit(); return res; } } // namespace // UTF16 UTF8 -------------------------------------------------------------- bool UTF8ToUTF16(const char* src, size_t src_len, std::u16string* output) { return UTFConversion(StringPiece(src, src_len), output); } std::u16string UTF8ToUTF16(StringPiece utf8) { std::u16string ret; // Ignore the success flag of this call, it will do the best it can for // invalid input, which is what we want here. UTF8ToUTF16(utf8.data(), utf8.size(), &ret); return ret; } bool UTF16ToUTF8(const char16_t* src, size_t src_len, std::string* output) { return UTFConversion(StringPiece16(src, src_len), output); } std::string UTF16ToUTF8(StringPiece16 utf16) { std::string ret; // Ignore the success flag of this call, it will do the best it can for // invalid input, which is what we want here. UTF16ToUTF8(utf16.data(), utf16.length(), &ret); return ret; } // UTF-16 Wide ------------------------------------------------------------- #if defined(WCHAR_T_IS_UTF16) // When wide == UTF-16 the conversions are a NOP. bool WideToUTF16(const wchar_t* src, size_t src_len, std::u16string* output) { output->assign(src, src + src_len); return true; } std::u16string WideToUTF16(WStringPiece wide) { return std::u16string(wide.begin(), wide.end()); } bool UTF16ToWide(const char16_t* src, size_t src_len, std::wstring* output) { output->assign(src, src + src_len); return true; } std::wstring UTF16ToWide(StringPiece16 utf16) { return std::wstring(utf16.begin(), utf16.end()); } #elif defined(WCHAR_T_IS_UTF32) bool WideToUTF16(const wchar_t* src, size_t src_len, std::u16string* output) { return UTFConversion(base::WStringPiece(src, src_len), output); } std::u16string WideToUTF16(WStringPiece wide) { std::u16string ret; // Ignore the success flag of this call, it will do the best it can for // invalid input, which is what we want here. WideToUTF16(wide.data(), wide.length(), &ret); return ret; } bool UTF16ToWide(const char16_t* src, size_t src_len, std::wstring* output) { return UTFConversion(StringPiece16(src, src_len), output); } std::wstring UTF16ToWide(StringPiece16 utf16) { std::wstring ret; // Ignore the success flag of this call, it will do the best it can for // invalid input, which is what we want here. UTF16ToWide(utf16.data(), utf16.length(), &ret); return ret; } #endif // defined(WCHAR_T_IS_UTF32) // UTF-8 Wide -------------------------------------------------------------- // UTF8ToWide is the same code, regardless of whether wide is 16 or 32 bits bool UTF8ToWide(const char* src, size_t src_len, std::wstring* output) { return UTFConversion(StringPiece(src, src_len), output); } std::wstring UTF8ToWide(StringPiece utf8) { std::wstring ret; // Ignore the success flag of this call, it will do the best it can for // invalid input, which is what we want here. UTF8ToWide(utf8.data(), utf8.length(), &ret); return ret; } #if defined(WCHAR_T_IS_UTF16) // Easy case since we can use the \"utf\" versions we already wrote above. bool WideToUTF8(const wchar_t* src, size_t src_len, std::string* output) { return UTF16ToUTF8(as_u16cstr(src), src_len, output); } std::string WideToUTF8(WStringPiece wide) { return UTF16ToUTF8(StringPiece16(as_u16cstr(wide), wide.size())); } #elif defined(WCHAR_T_IS_UTF32) bool WideToUTF8(const wchar_t* src, size_t src_len, std::string* output) { return UTFConversion(WStringPiece(src, src_len), output); } std::string WideToUTF8(WStringPiece wide) { std::string ret; // Ignore the success flag of this call, it will do the best it can for // invalid input, which is what we want here. WideToUTF8(wide.data(), wide.length(), &ret); return ret; } #endif // defined(WCHAR_T_IS_UTF32) std::u16string ASCIIToUTF16(StringPiece ascii) { DCHECK(IsStringASCII(ascii)) fuzzer // Entry point for LibFuzzer. extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) { base::StringPiece string_piece_input(reinterpret_cast(data), size); ignore_result(base::UTF8ToWide(string_piece_input)); base::UTF8ToWide(reinterpret_cast(data), size, &output_std_wstring); ignore_result(base::UTF8ToUTF16(string_piece_input)); base::UTF8ToUTF16(reinterpret_cast(data), size, &output_string16); // Test for char16_t. if (size % 2 == 0) { base::StringPiece16 string_piece_input16( reinterpret_cast(data), size / 2); ignore_result(base::UTF16ToWide(output_string16)); base::UTF16ToWide(reinterpret_cast(data), size / 2, &output_std_wstring); ignore_result(base::UTF16ToUTF8(string_piece_input16)); base::UTF16ToUTF8(reinterpret_cast(data), size / 2, &output_std_string); } // Test for wchar_t. size_t wchar_t_size = sizeof(wchar_t); if (size % wchar_t_size == 0) { ignore_result(base::WideToUTF8(output_std_wstring)); base::WideToUTF8(reinterpret_cast(data), size / wchar_t_size, &output_std_string); ignore_result(base::WideToUTF16(output_std_wstring)); base::WideToUTF16(reinterpret_cast(data), size / wchar_t_size, &output_string16); } // Test for ASCII. This condition is needed to avoid hitting instant CHECK // failures. if (base::IsStringASCII(string_piece_input)) { output_string16 = base::ASCIIToUTF16(string_piece_input); base::StringPiece16 string_piece_input16(output_string16); ignore_result(base::UTF16ToASCII(string_piece_input16)); } return 0; } new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/zi-fu-chuan-strings/kua-ping-tai-zi-fu-chu-li.html":{"url":"ji-shu-fen-xi/ji-chu-ku/zi-fu-chuan-strings/kua-ping-tai-zi-fu-chu-li.html","title":"跨平台字符处理","summary":"chrome跨平台字符处理","keywords":"","body":"跨平台字符处理相关文件方法定义跨平台实现windowsmacposix跨平台字符处理 使用计算机的过程中经常会看到一堆莫名其妙的符号（乱码），导致出现乱码的一个重要原因就是未能按照正确的编码格式对字符串解码。当出现两种编码方式不兼容的字符时就会出现乱码，为了正确的显示字符串就必须将其转换为对应的编码。以下介绍了chrome中实现的跨平台编码转换方式。 跨平台字符串处理涉及宽字节表示法与UTF-8表示法之间的转换和宽字节表示法与多字节表示法之间的转换。 相关文件 base/strings/sys_string_conversions.h // 方法定义 base/strings/sys_string_conversions_win.cc // windows系统下字符串处理 base/strings/sys_string_conversions_mac.mm // mac系统下字符串处理 base/strings/sys_string_conversions_posix.cc // 兼容posix系统下字符串处理 方法定义 首先定义了宽字节与UTF-8之间的转换，紧接着是宽字节与多字节之间的转换。根据不同系统又分别定义了windows、mac、posix下的转换方法。 使用时不用关系不同系统下的具体实现方式，只需要在前四个方法中选择需要的方法即可。chrome的这种方式极大的降低跨平台开发时字符串编码转换难度。 // base/strings/sys_string_conversions.h namespace base { // Converts between wide and UTF-8 representations of a string. On error, the // result is system-dependent. BASE_EXPORT std::string SysWideToUTF8(const std::wstring& wide) WARN_UNUSED_RESULT; BASE_EXPORT std::wstring SysUTF8ToWide(StringPiece utf8) WARN_UNUSED_RESULT; // Converts between wide and the system multi-byte representations of a string. // DANGER: This will lose information and can change (on Windows, this can // change between reboots). BASE_EXPORT std::string SysWideToNativeMB(const std::wstring& wide) WARN_UNUSED_RESULT; BASE_EXPORT std::wstring SysNativeMBToWide(StringPiece native_mb) WARN_UNUSED_RESULT; // Windows-specific ------------------------------------------------------------ #if defined(OS_WIN) // Converts between 8-bit and wide strings, using the given code page. The // code page identifier is one accepted by the Windows function // MultiByteToWideChar(). BASE_EXPORT std::wstring SysMultiByteToWide(StringPiece mb, uint32_t code_page) WARN_UNUSED_RESULT; BASE_EXPORT std::string SysWideToMultiByte(const std::wstring& wide, uint32_t code_page) WARN_UNUSED_RESULT; #endif // defined(OS_WIN) // Mac-specific ---------------------------------------------------------------- #if defined(OS_APPLE) // Converts between STL strings and CFStringRefs/NSStrings. // Creates a string, and returns it with a refcount of 1. You are responsible // for releasing it. Returns NULL on failure. BASE_EXPORT ScopedCFTypeRef SysUTF8ToCFStringRef(StringPiece utf8) WARN_UNUSED_RESULT; BASE_EXPORT ScopedCFTypeRef SysUTF16ToCFStringRef( StringPiece16 utf16) WARN_UNUSED_RESULT; // Same, but returns an autoreleased NSString. BASE_EXPORT NSString* SysUTF8ToNSString(StringPiece utf8) WARN_UNUSED_RESULT; BASE_EXPORT NSString* SysUTF16ToNSString(StringPiece16 utf16) WARN_UNUSED_RESULT; // Converts a CFStringRef to an STL string. Returns an empty string on failure. BASE_EXPORT std::string SysCFStringRefToUTF8(CFStringRef ref) WARN_UNUSED_RESULT; BASE_EXPORT std::u16string SysCFStringRefToUTF16(CFStringRef ref) WARN_UNUSED_RESULT; // Same, but accepts NSString input. Converts nil NSString* to the appropriate // string type of length 0. BASE_EXPORT std::string SysNSStringToUTF8(NSString* ref) WARN_UNUSED_RESULT; BASE_EXPORT std::u16string SysNSStringToUTF16(NSString* ref) WARN_UNUSED_RESULT; #endif // defined(OS_APPLE) } // namespace base 跨平台实现 windows windows下使用了两个关键的api分别是，MultiByteToWideChar、WideCharToMultiByte。chrome基于这两个函数实现了宽字节与UTF-8、宽字节与多字节，在windows系统下的转换。 // base/strings/sys_string_conversions_win.cc namespace base { // Do not assert in this function since it is used by the asssertion code! std::string SysWideToUTF8(const std::wstring& wide) { return SysWideToMultiByte(wide, CP_UTF8); } // Do not assert in this function since it is used by the asssertion code! std::wstring SysUTF8ToWide(StringPiece utf8) { return SysMultiByteToWide(utf8, CP_UTF8); } std::string SysWideToNativeMB(const std::wstring& wide) { return SysWideToMultiByte(wide, CP_ACP); } std::wstring SysNativeMBToWide(StringPiece native_mb) { return SysMultiByteToWide(native_mb, CP_ACP); } // Do not assert in this function since it is used by the asssertion code! std::wstring SysMultiByteToWide(StringPiece mb, uint32_t code_page) { if (mb.empty()) return std::wstring(); int mb_length = static_cast(mb.length()); // Compute the length of the buffer. int charcount = MultiByteToWideChar(code_page, 0, mb.data(), mb_length, NULL, 0); if (charcount == 0) return std::wstring(); std::wstring wide; wide.resize(charcount); MultiByteToWideChar(code_page, 0, mb.data(), mb_length, &wide[0], charcount); return wide; } // Do not assert in this function since it is used by the asssertion code! std::string SysWideToMultiByte(const std::wstring& wide, uint32_t code_page) { int wide_length = static_cast(wide.length()); if (wide_length == 0) return std::string(); // Compute the length of the buffer we'll need. int charcount = WideCharToMultiByte(code_page, 0, wide.data(), wide_length, NULL, 0, NULL, NULL); if (charcount == 0) return std::string(); std::string mb; mb.resize(charcount); WideCharToMultiByte(code_page, 0, wide.data(), wide_length, &mb[0], charcount, NULL, NULL); return mb; } } // namespace base mac 相对于windows下的实现，mac的实现看上去略现复杂。主要原因在于mac中的字符串涉及到CFString和NSString，它们可以被C++、Objective-C、Swift使用。 // base/strings/sys_string_conversions_mac.mm namespace base { namespace { // Convert the supplied CFString into the specified encoding, and return it as // an STL string of the template type. Returns an empty string on failure. // // Do not assert in this function since it is used by the asssertion code! template static StringType CFStringToSTLStringWithEncodingT(CFStringRef cfstring, CFStringEncoding encoding) { CFIndex length = CFStringGetLength(cfstring); if (length == 0) return StringType(); CFRange whole_string = CFRangeMake(0, length); CFIndex out_size; CFIndex converted = CFStringGetBytes(cfstring, whole_string, encoding, 0, // lossByte false, // isExternalRepresentation NULL, // buffer 0, // maxBufLen &out_size); if (converted == 0 || out_size == 0) return StringType(); // out_size is the number of UInt8-sized units needed in the destination. // A buffer allocated as UInt8 units might not be properly aligned to // contain elements of StringType::value_type. Use a container for the // proper value_type, and convert out_size by figuring the number of // value_type elements per UInt8. Leave room for a NUL terminator. typename StringType::size_type elements = out_size * sizeof(UInt8) / sizeof(typename StringType::value_type) + 1; std::vector out_buffer(elements); converted = CFStringGetBytes(cfstring, whole_string, encoding, 0, // lossByte false, // isExternalRepresentation reinterpret_cast(&out_buffer[0]), out_size, NULL); // usedBufLen if (converted == 0) return StringType(); out_buffer[elements - 1] = '\\0'; return StringType(&out_buffer[0], elements - 1); } // Given an STL string |in| with an encoding specified by |in_encoding|, // convert it to |out_encoding| and return it as an STL string of the // |OutStringType| template type. Returns an empty string on failure. // // Do not assert in this function since it is used by the asssertion code! template static OutStringType STLStringToSTLStringWithEncodingsT( const InStringType& in, CFStringEncoding in_encoding, CFStringEncoding out_encoding) { typename InStringType::size_type in_length = in.length(); if (in_length == 0) return OutStringType(); base::ScopedCFTypeRef cfstring(CFStringCreateWithBytesNoCopy( NULL, reinterpret_cast(in.data()), in_length * sizeof(typename InStringType::value_type), in_encoding, false, kCFAllocatorNull)); if (!cfstring) return OutStringType(); return CFStringToSTLStringWithEncodingT(cfstring, out_encoding); } // Given a StringPiece |in| with an encoding specified by |in_encoding|, return // it as a CFStringRef. Returns NULL on failure. template static ScopedCFTypeRef StringPieceToCFStringWithEncodingsT( BasicStringPiece in, CFStringEncoding in_encoding) { const auto in_length = in.length(); if (in_length == 0) return ScopedCFTypeRef(CFSTR(\"\"), base::scoped_policy::RETAIN); return ScopedCFTypeRef(CFStringCreateWithBytes( kCFAllocatorDefault, reinterpret_cast(in.data()), in_length * sizeof(CharT), in_encoding, false)); } // Specify the byte ordering explicitly, otherwise CFString will be confused // when strings don't carry BOMs, as they typically won't. static const CFStringEncoding kNarrowStringEncoding = kCFStringEncodingUTF8; #ifdef __BIG_ENDIAN__ static const CFStringEncoding kMediumStringEncoding = kCFStringEncodingUTF16BE; static const CFStringEncoding kWideStringEncoding = kCFStringEncodingUTF32BE; #elif defined(__LITTLE_ENDIAN__) static const CFStringEncoding kMediumStringEncoding = kCFStringEncodingUTF16LE; static const CFStringEncoding kWideStringEncoding = kCFStringEncodingUTF32LE; #endif // __LITTLE_ENDIAN__ } // namespace // Do not assert in this function since it is used by the asssertion code! std::string SysWideToUTF8(const std::wstring& wide) { return STLStringToSTLStringWithEncodingsT( wide, kWideStringEncoding, kNarrowStringEncoding); } // Do not assert in this function since it is used by the asssertion code! std::wstring SysUTF8ToWide(StringPiece utf8) { return STLStringToSTLStringWithEncodingsT( utf8, kNarrowStringEncoding, kWideStringEncoding); } std::string SysWideToNativeMB(const std::wstring& wide) { return SysWideToUTF8(wide); } std::wstring SysNativeMBToWide(StringPiece native_mb) { return SysUTF8ToWide(native_mb); } ScopedCFTypeRef SysUTF8ToCFStringRef(StringPiece utf8) { return StringPieceToCFStringWithEncodingsT(utf8, kNarrowStringEncoding); } ScopedCFTypeRef SysUTF16ToCFStringRef(StringPiece16 utf16) { return StringPieceToCFStringWithEncodingsT(utf16, kMediumStringEncoding); } NSString* SysUTF8ToNSString(StringPiece utf8) { return [mac::CFToNSCast(SysUTF8ToCFStringRef(utf8).release()) autorelease]; } NSString* SysUTF16ToNSString(StringPiece16 utf16) { return [mac::CFToNSCast(SysUTF16ToCFStringRef(utf16).release()) autorelease]; } std::string SysCFStringRefToUTF8(CFStringRef ref) { return CFStringToSTLStringWithEncodingT(ref, kNarrowStringEncoding); } std::u16string SysCFStringRefToUTF16(CFStringRef ref) { return CFStringToSTLStringWithEncodingT( ref, kMediumStringEncoding); } std::string SysNSStringToUTF8(NSString* nsstring) { if (!nsstring) return std::string(); return SysCFStringRefToUTF8(reinterpret_cast(nsstring)); } std::u16string SysNSStringToUTF16(NSString* nsstring) { if (!nsstring) return std::u16string(); return SysCFStringRefToUTF16(reinterpret_cast(nsstring)); } } // namespace base posix posix下对部分系统又做了不同处理，部分实现不在一下代码片段中。SysWideToNativeMB和SysNativeMBToWide的实现方式能够更容易看清宽字节与多字节转换的本质。 // base/strings/sys_string_conversions_posix.cc namespace base { std::string SysWideToUTF8(const std::wstring& wide) { // In theory this should be using the system-provided conversion rather // than our ICU, but this will do for now. return WideToUTF8(wide); } std::wstring SysUTF8ToWide(StringPiece utf8) { // In theory this should be using the system-provided conversion rather // than our ICU, but this will do for now. std::wstring out; UTF8ToWide(utf8.data(), utf8.size(), &out); return out; } #if defined(SYSTEM_NATIVE_UTF8) || defined(OS_ANDROID) // TODO(port): Consider reverting the OS_ANDROID when we have wcrtomb() // support and a better understanding of what calls these routines. std::string SysWideToNativeMB(const std::wstring& wide) { return WideToUTF8(wide); } std::wstring SysNativeMBToWide(StringPiece native_mb) { return SysUTF8ToWide(native_mb); } #else std::string SysWideToNativeMB(const std::wstring& wide) { mbstate_t ps; // Calculate the number of multi-byte characters. We walk through the string // without writing the output, counting the number of multi-byte characters. size_t num_out_chars = 0; memset(&ps, 0, sizeof(ps)); for (auto src : wide) { // Use a temp buffer since calling wcrtomb with an output of NULL does not // calculate the output length. char buf[16]; // Skip NULLs to avoid wcrtomb's special handling of them. size_t res = src ? wcrtomb(buf, src, &ps) : 0; switch (res) { // Handle any errors and return an empty string. case static_cast(-1): return std::string(); case 0: // We hit an embedded null byte, keep going. ++num_out_chars; break; default: num_out_chars += res; break; } } if (num_out_chars == 0) return std::string(); std::string out; out.resize(num_out_chars); // We walk the input string again, with |i| tracking the index of the // wide input, and |j| tracking the multi-byte output. memset(&ps, 0, sizeof(ps)); for (size_t i = 0, j = 0; i (-1): return std::string(); case 0: // We hit an embedded null byte, keep going. ++j; // Output is already zeroed. break; default: j += res; break; } } return out; } std::wstring SysNativeMBToWide(StringPiece native_mb) { mbstate_t ps; // Calculate the number of wide characters. We walk through the string // without writing the output, counting the number of wide characters. size_t num_out_chars = 0; memset(&ps, 0, sizeof(ps)); for (size_t i = 0; i (-2): case static_cast(-1): return std::wstring(); case 0: // We hit an embedded null byte, keep going. i += 1; FALLTHROUGH; default: i += res; ++num_out_chars; break; } } if (num_out_chars == 0) return std::wstring(); std::wstring out; out.resize(num_out_chars); memset(&ps, 0, sizeof(ps)); // Clear the shift state. // We walk the input string again, with |i| tracking the index of the // multi-byte input, and |j| tracking the wide output. for (size_t i = 0, j = 0; i (-2): case static_cast(-1): return std::wstring(); case 0: i += 1; // Skip null byte. break; default: i += res; break; } } return out; } #endif // defined(SYSTEM_NATIVE_UTF8) || defined(OS_ANDROID) } // namespace base new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/fen-xi-qi-profiler.html":{"url":"ji-shu-fen-xi/ji-chu-ku/fen-xi-qi-profiler.html","title":"分析器（profiler）","keywords":"","body":"分析器（profiler）分析器（profiler） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/jin-cheng-process.html":{"url":"ji-shu-fen-xi/ji-chu-ku/jin-cheng-process.html","title":"进程（process）","keywords":"","body":"进程（process）进程（process） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/dian-yuan-jian-kong-powermonitor.html":{"url":"ji-shu-fen-xi/ji-chu-ku/dian-yuan-jian-kong-powermonitor.html","title":"电源监控(power_monitor)","keywords":"","body":"电源监控(power_monitor)电源监控(power_monitor) new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/posix.html":{"url":"ji-shu-fen-xi/ji-chu-ku/posix.html","title":"posix","keywords":"","body":"posixposix new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/shu-zi-numerics.html":{"url":"ji-shu-fen-xi/ji-chu-ku/shu-zi-numerics.html","title":"数字（numerics）","summary":"基本的数学运算和转换","keywords":"","body":"数字（numerics）数字（numerics） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/du-liang-metrics.html":{"url":"ji-shu-fen-xi/ji-chu-ku/du-liang-metrics.html","title":"度量（metrics）","keywords":"","body":"度量（metrics）度量（metrics） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/xiao-xi-xun-huan-messageloop.html":{"url":"ji-shu-fen-xi/ji-chu-ku/xiao-xi-xun-huan-messageloop.html","title":"消息循环（message_loop）","keywords":"","body":"消息循环（message_loop）消息循环（message_loop） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/nei-cun-memory.html":{"url":"ji-shu-fen-xi/ji-chu-ku/nei-cun-memory.html","title":"内存（memory）","summary":"跨平台共享内存","keywords":"","body":"内存（memory）内存（memory） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/mac.html":{"url":"ji-shu-fen-xi/ji-chu-ku/mac.html","title":"mac","keywords":"","body":"macmac new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/json.html":{"url":"ji-shu-fen-xi/ji-chu-ku/json.html","title":"json","summary":"json数据处理","keywords":"","body":"jsonjson new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/guo-ji-hua-i18n.html":{"url":"ji-shu-fen-xi/ji-chu-ku/guo-ji-hua-i18n.html","title":"国际化（i18n）","keywords":"","body":"国际化（i18n）国际化（i18n） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/ha-xi-hash.html":{"url":"ji-shu-fen-xi/ji-chu-ku/ha-xi-hash.html","title":"哈希（hash）","keywords":"","body":"哈希（hash）哈希（hash） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/fuchsia.html":{"url":"ji-shu-fen-xi/ji-chu-ku/fuchsia.html","title":"fuchsia","summary":"google新研发的系统","keywords":"","body":"fuchsiafuchsia new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/wen-jian-files.html":{"url":"ji-shu-fen-xi/ji-chu-ku/wen-jian-files.html","title":"文件（files）","summary":"跨平台文件此操作","keywords":"","body":"文件（files）文件（files） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/tiao-shi-qi-debug.html":{"url":"ji-shu-fen-xi/ji-chu-ku/tiao-shi-qi-debug.html","title":"调试器（debug）","summary":"跨平台的调试于分析","keywords":"","body":"调试器（debug）调试器（debug） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/rong-qi-containers.html":{"url":"ji-shu-fen-xi/ji-chu-ku/rong-qi-containers.html","title":"容器（containers）","summary":"包含类似于STL的容器","keywords":"","body":"容器（containers）容器（containers） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"ji-shu-fen-xi/ji-chu-ku/fen-pei-qi-allocator.html":{"url":"ji-shu-fen-xi/ji-chu-ku/fen-pei-qi-allocator.html","title":"分配器（allocator）","summary":"跨平台malloc/new调用","keywords":"","body":"分配器（allocator）分配器（allocator） new Valine({el: \"#vcomments\",appId: 'yXcCO0WwH1N4pXiJ4a7cLaJV-gzGzoHsz',appKey: 'snSYunAWY2mBjfimkM7wlTk9',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}